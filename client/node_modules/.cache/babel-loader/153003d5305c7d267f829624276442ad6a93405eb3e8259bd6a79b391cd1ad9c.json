{"ast":null,"code":"import * as PIXI from \"pixi.js\";\nexport class Card {\n  constructor(cardsContainer, sheet, name, position) {\n    this.cardsContainer = cardsContainer;\n    this.sheet = sheet;\n    this.name = name;\n    this.position = position;\n    this.place = \"tavern\";\n    this.selected = false;\n    this.sprite = new PIXI.Sprite(this.sheet.textures[\"tile028.jpg\"]);\n    this.sprite.eventMode = 'static';\n    this.sprite.cursor = 'pointer';\n    this.sprite.x = this.position.x;\n    this.sprite.y = this.position.y;\n    this.sprite.scale.set(0.4);\n    this.sprite.anchor.set(0.5);\n    this.shadowFilter = new PIXI.Filter(null, `\n        precision mediump float;\n        uniform sampler2D uSampler;\n        varying vec2 vTextureCoord;\n    \n        void main(void) {\n            // Get the pixel color from the texture\n            vec4 texColor = texture2D(uSampler, vTextureCoord);\n            \n            // Define border thickness and shadow parameters\n            float borderThickness = 0.02;\n            float shadowDistance = 0.02;\n            float shadowBlur = 0.1;\n            vec3 shadowColor = vec3(0.0, 0.0, 0.0);\n            float shadowAlpha = 0.7;\n    \n            // Create a border\n            if (vTextureCoord.x < borderThickness || vTextureCoord.x > 1.0 - borderThickness ||\n                vTextureCoord.y < borderThickness || vTextureCoord.y > 1.0 - borderThickness) {\n                texColor = vec4(shadowColor, shadowAlpha);\n            }\n    \n            // Apply shadow\n            if (vTextureCoord.x > borderThickness + shadowDistance && \n                vTextureCoord.y > borderThickness + shadowDistance &&\n                vTextureCoord.x < 1.0 - borderThickness - shadowDistance &&\n                vTextureCoord.y < 1.0 - borderThickness - shadowDistance) {\n                float shadow = smoothstep(borderThickness + shadowDistance, borderThickness, vTextureCoord.x) *\n                              smoothstep(borderThickness + shadowDistance, borderThickness, 1.0 - vTextureCoord.x) *\n                              smoothstep(borderThickness + shadowDistance, borderThickness, vTextureCoord.y) *\n                              smoothstep(borderThickness + shadowDistance, borderThickness, 1.0 - vTextureCoord.y);\n                texColor.rgb = mix(texColor.rgb, shadowColor, shadow * shadowAlpha);\n            }\n    \n            gl_FragColor = texColor;\n        }\n    `);\n    this.sprite.filters = [this.shadowFilter];\n    this.cardsContainer.addChild(this.sprite);\n    this.sprite.on('pointerover', this.onPointerOver, this.sprite).on('pointerout', this.onPointerOut, this.sprite).on('pointerdown', () => {\n      this.selected = !this.selected;\n    });\n  }\n  reveal() {\n    this.sprite.texture = this.sheet.textures[this.name];\n  }\n  hide() {\n    this.sprite.texture = this.sheet.textures[\"tile028.jpg\"];\n  }\n  onPointerOver() {\n    this.tint = 0x666666;\n  }\n  onPointerOut() {\n    this.tint = 0xFFFFFF;\n  }\n  moveTo(position, revealed) {\n    if (revealed) {\n      this.reveal();\n    } else {\n      this.hide();\n    }\n    const ticker = new PIXI.Ticker();\n    ticker.add(delta => {\n      // Constants\n      const velocity = 40;\n\n      // Calculate direction towards position\n      let dx = position.x - this.sprite.x;\n      let dy = position.y - this.sprite.y;\n\n      // Normalize\n      let distance = Math.sqrt(dx * dx + dy * dy);\n      dx = dx / distance;\n      dy = dy / distance;\n\n      // Move Card towards position\n      if (distance <= velocity) {\n        this.sprite.x = position.x;\n        this.sprite.y = position.y;\n        this.position = position;\n        ticker.destroy();\n      } else {\n        this.sprite.x += dx * velocity * delta;\n        this.sprite.y += dy * velocity * delta;\n      }\n    });\n    ticker.start();\n  }\n}","map":{"version":3,"names":["PIXI","Card","constructor","cardsContainer","sheet","name","position","place","selected","sprite","Sprite","textures","eventMode","cursor","x","y","scale","set","anchor","shadowFilter","Filter","filters","addChild","on","onPointerOver","onPointerOut","reveal","texture","hide","tint","moveTo","revealed","ticker","Ticker","add","delta","velocity","dx","dy","distance","Math","sqrt","destroy","start"],"sources":["/Users/rabiibouhestine/mystuff/BrowserApps/Duels/client/src/game/components/Card.js"],"sourcesContent":["import * as PIXI from \"pixi.js\";\n\nexport class Card {\n    constructor(cardsContainer, sheet, name, position) {\n        this.cardsContainer = cardsContainer;\n        this.sheet = sheet;\n        this.name = name;\n        this.position = position;\n        this.place = \"tavern\";\n        this.selected = false;\n\n        this.sprite = new PIXI.Sprite(this.sheet.textures[\"tile028.jpg\"]);\n        this.sprite.eventMode = 'static';\n        this.sprite.cursor = 'pointer';\n        this.sprite.x = this.position.x;\n        this.sprite.y = this.position.y;\n        this.sprite.scale.set(0.4);\n        this.sprite.anchor.set(0.5);\n        this.shadowFilter = new PIXI.Filter(null, `\n        precision mediump float;\n        uniform sampler2D uSampler;\n        varying vec2 vTextureCoord;\n    \n        void main(void) {\n            // Get the pixel color from the texture\n            vec4 texColor = texture2D(uSampler, vTextureCoord);\n            \n            // Define border thickness and shadow parameters\n            float borderThickness = 0.02;\n            float shadowDistance = 0.02;\n            float shadowBlur = 0.1;\n            vec3 shadowColor = vec3(0.0, 0.0, 0.0);\n            float shadowAlpha = 0.7;\n    \n            // Create a border\n            if (vTextureCoord.x < borderThickness || vTextureCoord.x > 1.0 - borderThickness ||\n                vTextureCoord.y < borderThickness || vTextureCoord.y > 1.0 - borderThickness) {\n                texColor = vec4(shadowColor, shadowAlpha);\n            }\n    \n            // Apply shadow\n            if (vTextureCoord.x > borderThickness + shadowDistance && \n                vTextureCoord.y > borderThickness + shadowDistance &&\n                vTextureCoord.x < 1.0 - borderThickness - shadowDistance &&\n                vTextureCoord.y < 1.0 - borderThickness - shadowDistance) {\n                float shadow = smoothstep(borderThickness + shadowDistance, borderThickness, vTextureCoord.x) *\n                              smoothstep(borderThickness + shadowDistance, borderThickness, 1.0 - vTextureCoord.x) *\n                              smoothstep(borderThickness + shadowDistance, borderThickness, vTextureCoord.y) *\n                              smoothstep(borderThickness + shadowDistance, borderThickness, 1.0 - vTextureCoord.y);\n                texColor.rgb = mix(texColor.rgb, shadowColor, shadow * shadowAlpha);\n            }\n    \n            gl_FragColor = texColor;\n        }\n    `);\n        this.sprite.filters = [this.shadowFilter];\n        this.cardsContainer.addChild(this.sprite);\n\n        this.sprite\n            .on('pointerover', this.onPointerOver, this.sprite)\n            .on('pointerout', this.onPointerOut, this.sprite)\n            .on('pointerdown', () => {this.selected = !this.selected;});\n    }\n\n    reveal() {\n        this.sprite.texture = this.sheet.textures[this.name];\n    }\n\n    hide() {\n        this.sprite.texture = this.sheet.textures[\"tile028.jpg\"];\n    }\n\n    onPointerOver()\n    {\n        this.tint = 0x666666;\n    }\n\n    onPointerOut()\n    {\n        this.tint = 0xFFFFFF;\n    }\n\n    moveTo(position, revealed) {\n        if (revealed) {\n            this.reveal();\n        } else {\n            this.hide();\n        }\n        const ticker = new PIXI.Ticker();\n        ticker.add((delta) =>\n        {\n            // Constants\n            const velocity = 40;\n\n            // Calculate direction towards position\n            let dx = position.x - this.sprite.x;\n            let dy = position.y - this.sprite.y;\n\n            // Normalize\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            dx = dx / distance;\n            dy = dy / distance;\n\n            // Move Card towards position\n            if (distance <= velocity) {\n                this.sprite.x = position.x;\n                this.sprite.y = position.y;\n                this.position = position;\n                ticker.destroy();\n            } else {\n                this.sprite.x += dx * velocity * delta;\n                this.sprite.y += dy * velocity * delta;\n            }\n        });\n        ticker.start()\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}